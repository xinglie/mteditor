/*!
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */
(function(d){	const l = d['zh-cn'] = d['zh-cn'] || {};	l.dictionary=Object.assign(		l.dictionary||{},		{"%0 of %1":"第 %0 步，共 %1 步","Align cell text to the bottom":"使单元格文本对齐到底部","Align cell text to the center":"使单元格文本水平居中","Align cell text to the left":"使单元格文本左对齐","Align cell text to the middle":"使单元格文本垂直居中","Align cell text to the right":"使单元格文本右对齐","Align cell text to the top":"使单元格文本对齐到顶部","Align center":"居中对齐","Align left":"左对齐","Align right":"右对齐","Align table to the left":"使表格左对齐","Align table to the right":"使表格右对齐",Alignment:"对齐",Aquamarine:"海蓝色",Background:"背景",Big:"大",Black:"黑色","Block quote":"块引用",Blue:"蓝色",Bold:"加粗",Border:"边框","Bulleted List":"项目符号列表","Bulleted list styles toolbar":"项目符号列表样式工具条",Cancel:"取消","Cell properties":"单元格属性","Center table":"表格居中","Centered image":"图片居中","Change image text alternative":"更改图片替换文本",Circle:"空心圆点",Color:"颜色","Color picker":"颜色选择器",Column:"列",Dashed:"虚线",Decimal:"阿拉伯数字","Decimal with leading zero":"前导零阿拉伯数字","Decrease indent":"减少缩进",Default:"默认","Delete column":"删除本列","Delete row":"删除本行","Dim grey":"暗灰色",Dimensions:"尺寸",Disc:"实心圆点","Document colors":"文档中的颜色",Dotted:"点状虚线",Double:"双线",Downloadable:"可下载","Dropdown toolbar":"下拉工具栏","Edit link":"修改链接","Editor toolbar":"编辑器工具栏","Enter image caption":"输入图片标题","Font Background Color":"字体背景色","Font Color":"字体颜色","Font Family":"字体","Font Size":"字体大小","Full size image":"图片通栏显示",Green:"绿色",Grey:"灰色",Groove:"凹槽边框","Header column":"标题列","Header row":"标题行",Height:"高度","Horizontal text alignment toolbar":"水平文本对齐工具栏",Huge:"极大","Image resize list":"图片大小列表","Image toolbar":"图片工具栏","image widget":"图像小部件","Increase indent":"增加缩进","Insert column left":"左侧插入列","Insert column right":"右侧插入列","Insert non-editable date":"插入不可修改日期","Insert paragraph after block":"在后面插入段落","Insert paragraph before block":"在前面插入段落","Insert row above":"在上面插入一行","Insert row below":"在下面插入一行","Insert table":"插入表格",Inset:"凹边框",Italic:"倾斜",Justify:"两端对齐","Justify cell text":"对齐单元格文本","Left aligned image":"图片左侧对齐","Light blue":"浅蓝色","Light green":"浅绿色","Light grey":"浅灰色",Link:"超链接","Link URL":"链接网址","Lower-latin":"小写拉丁字母","Lower–roman":"小写罗马数字","Merge cell down":"向下合并单元格","Merge cell left":"向左合并单元格","Merge cell right":"向右合并单元格","Merge cell up":"向上合并单元格","Merge cells":"合并单元格",Next:"下一步",None:"无","Numbered List":"项目编号列表","Numbered list styles toolbar":"项目编号列表样式工具条","Open in a new tab":"在新标签页中打开","Open link in new tab":"在新标签页中打开链接",Orange:"橙色",Original:"原始大小",Outset:"凸边框",Padding:"内边距","Page break":"分页符",Previous:"上一步",Purple:"紫色",Red:"红色",Redo:"重做","Remove color":"移除颜色","Remove Format":"移除格式","Resize image":"调整图像大小","Resize image to %0":"调整图像大小为0%","Resize image to the original size":"调整图像大小为原始大小","Rich Text Editor, %0":"富文本编辑器， %0",Ridge:"垄状边框","Right aligned image":"图片右侧对齐",Row:"行",Save:"保存","Select column":"选择列","Select row":"选择行","Show more items":"显示更多","Side image":"图片侧边显示",Small:"小",Solid:"实线","Split cell horizontally":"横向拆分单元格","Split cell vertically":"纵向拆分单元格",Square:"实心方块",Strikethrough:"删除线",Style:"样式","Table alignment toolbar":"表格对齐工具栏","Table cell text alignment":"表格单元格中的文本水平对齐","Table properties":"表格属性","Table toolbar":"表格工具栏","Text alignment":"对齐","Text alignment toolbar":"对齐工具栏","Text alternative":"替换文本","Text holder":"文本占位符","Text holder name":"占位符名称","The color is invalid. Try \"#FF0000\" or \"rgb(255,0,0)\" or \"red\".":"颜色无效。尝试使用\"#FF0000\"、\"rgb(255,0,0)\"或者\"red\"。","The value is invalid. Try \"10px\" or \"2em\" or simply \"2\".":"无效值。尝试使用“10px”、“2ex”或者只写“2”。","This link has no URL":"此链接没有设置网址",Tiny:"极小","Toggle the circle list style":"切换空心原点列表样式","Toggle the decimal list style":"切换阿拉伯数字列表样式","Toggle the decimal with leading zero list style":"切换前导零阿拉伯数字列表样式","Toggle the disc list style":"切换实心原点列表样式","Toggle the lower–latin list style":"切换小写拉丁字母列表样式","Toggle the lower–roman list style":"切换小写罗马数字列表样式","Toggle the square list style":"切换实心方块列表样式","Toggle the upper–latin list style":"切换大写拉丁字母列表样式","Toggle the upper–roman list style":"切换大写罗马数字列表样式",Turquoise:"青色",Underline:"下划线",Undo:"撤销",Unlink:"取消超链接","Upper-latin":"大写拉丁字母","Upper-roman":"大写罗马数字","Vertical text alignment toolbar":"垂直文本对齐工具栏",White:"白色","Widget toolbar":"小部件工具栏",Width:"宽度",Yellow:"黄色"}	);l.getPluralForm=function(n){return 0;;};})(window.CKEDITOR_TRANSLATIONS||(window.CKEDITOR_TRANSLATIONS={}));
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["MagicalTextEditor"] = factory();
	else
		root["MagicalTextEditor"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 2);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./plugins/mark.js":
/*!*************************!*\
  !*** ./plugins/mark.js ***!
  \*************************/
/*! exports provided: mark, unmark */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mark\", function() { return mark; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unmark\", function() { return unmark; });\nfunction mark(host, key) {\n    let deletedKey = '#mark.object.deleted';\n    let markObjectKey = '#mark.object';\n    let sign;\n    if (!host[deletedKey]) {\n        let markHost = host[markObjectKey] || (host[markObjectKey] = {});\n        if (!markHost.hasOwnProperty(key)) {\n            markHost[key] = 0;\n        }\n        sign = ++markHost[key];\n    }\n    return () => {\n        let temp = host[markObjectKey];\n        return temp && sign === temp[key];\n    }\n};\nfunction unmark(host) {\n    host['#mark.object'] = 0;\n    host['#mark.object.deleted'] = 1;\n};\n\n//# sourceURL=webpack://MagicalTextEditor/./plugins/mark.js?");

/***/ }),

/***/ "./plugins/task.js":
/*!*************************!*\
  !*** ./plugins/task.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nlet Timeout = window.setTimeout;\nlet Date_Now = Date.now;\nlet CallIndex = 0;\nlet CallList = [];\nlet CallBreakTime = 8;\nlet Null = null;\nlet Noop = () => { };\nlet IsArray = Array.isArray;\nlet StartCall = () => {\n    let last = Date_Now(),\n        next, args, context;\n    try {\n        while (CallBreakTime) {\n            next = CallList[CallIndex];\n            context = CallList[CallIndex - 1];\n            args = CallList[CallIndex + 1];\n            CallList[CallIndex] = Null;\n            CallList[CallIndex - 1] = Null;\n            CallList[CallIndex + 1] = Null;\n            CallList[CallIndex + 2] = Null;\n            CallIndex += 4;\n            if (next) {\n                if (next != Noop) {\n                    if (IsArray(args)) {\n                        next.apply(context, args);\n                    } else {\n                        next.call(context, args);\n                    }\n                }\n                if (Date_Now() - last > CallBreakTime &&\n                    CallList.length > CallIndex) {\n                    Timeout(StartCall);\n                    console.log(`[CF] take a break of ${CallList.length} at ${CallIndex}`);\n                    break;\n                }\n            } else {\n                CallList.length = CallIndex = 0;\n                break;\n            }\n        }\n    } catch (ex) {\n        console.error(ex);\n        Timeout(StartCall);\n    }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = ((fn, args, context, id) => {\n    if (!CallIndex) {\n        CallIndex = 1;\n        Timeout(StartCall);\n    }\n    if (id) {\n        for (let i = CallList.length - 1; i >= CallIndex; i -= 4) {\n            if (CallList[i] == id) {\n                CallList[i - 3] = Null;\n                CallList[i - 2] = Noop;\n                CallList[i - 1] = Null;\n                CallList[i] = Null;\n                console.log('ignore id', id);\n            }\n        }\n    }\n    CallList.push(context, fn, args, id);\n});\n\n//# sourceURL=webpack://MagicalTextEditor/./plugins/task.js?");

/***/ }),

/***/ "./plugins/taskcomplete.js":
/*!*********************************!*\
  !*** ./plugins/taskcomplete.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _task_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./task.js */ \"./plugins/task.js\");\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (callback => {\n    let taskCount = 0;\n    let calledCount = 0;\n    let taskCheck = (...args) => {\n        calledCount++;\n        if (calledCount == taskCount) {\n            callback(...args);\n        }\n    }\n    return (...args) => {\n        taskCount++;\n        Object(_task_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(taskCheck, [...args]);\n    };\n});\n\n//# sourceURL=webpack://MagicalTextEditor/./plugins/taskcomplete.js?");

/***/ }),

/***/ "./src/mteditor-print.js":
/*!*******************************!*\
  !*** ./src/mteditor-print.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return MagicalTextEditor; });\n/* harmony import */ var _plugins_task__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../plugins/task */ \"./plugins/task.js\");\n/* harmony import */ var _plugins_taskcomplete__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../plugins/taskcomplete */ \"./plugins/taskcomplete.js\");\n/* harmony import */ var _plugins_mark__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../plugins/mark */ \"./plugins/mark.js\");\n\n\n\n\nlet appendLine = line => {\n    let div = document.createElement('div');\n    div.style.cssText = `position:absolute;left:170mm;width:170mm;top:${line}px;height:1px;background:red`;\n    document.body.appendChild(div);\n};\n\nlet range = document.createRange();\nlet isString = str => Object.prototype.toString.call(str) == '[object String]';\nlet insetReg = /inset\\((\\d+)px (\\d+)px (\\d+)px\\)/;\nlet getClipPath = clip => {\n    let m = clip.match(insetReg);\n    if (m) {\n        return [m[1] | 0, m[2] | 0, m[3] | 0];\n    }\n    return [0, 0, 0];\n};\nlet getDOMRef = content => {\n    if (content) {\n        let root = document.createElement('div');\n        root.style.cssText = `position:absolute;left:-10000px;top:-10000px`;\n        if (isString(content)) {\n            let parser = new DOMParser();\n            let doc = parser.parseFromString(content, 'text/html');\n            let body = doc.body;\n            while (body.childNodes.length) {\n                root.appendChild(body.firstChild);\n            }\n        } else if (content.cloneNode) {\n            let start = 0,\n                end = content.childNodes.length;\n            while (start < end) {\n                root.appendChild(content.childNodes[start].cloneNode(true));\n                start++;\n            }\n        } else {\n            return null;\n        }\n        document.body.appendChild(root);\n        return root;\n    }\n    return null;\n};\nlet fixBound = b => {\n    return {\n        x: b.left + window.pageXOffset,\n        y: b.top + window.pageYOffset,\n        width: b.width,\n        height: b.height\n    }\n};\nlet getRectsFromElement = element => {\n    return new Promise(resolve => {\n        let rects = [];\n\n        let checkIfReady = Object(_plugins_taskcomplete__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(() => {\n            resolve(rects);\n        });\n\n        let collectRects = node => {\n            if (node.nodeType == 3) {\n                let len = 0;\n                while (len < node.length) {\n                    range.setStart(node, len);\n                    range.setEnd(node, len + 1);\n                    let rect = range.getBoundingClientRect();\n                    if (rect.height) {\n                        rects.push(fixBound(rect));\n                    }\n                    len++;\n                }\n            } else {\n                range.setStartBefore(node);\n                range.setEndAfter(node);\n                let rect = range.getBoundingClientRect();\n                rects.push(fixBound(rect));\n            }\n        };\n        let walk = nodes => {\n            for (let e of nodes) {\n                if (e.nodeType == 3) {\n                    Object(_plugins_task__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(collectRects, [e]);\n                    checkIfReady();\n                } else if (e.nodeType == 1) {\n                    if (e.childNodes.length &&\n                        e.className != 'page-break') {\n                        Object(_plugins_task__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(walk, [Array.from(e.childNodes)]);\n                        checkIfReady();\n                    } else if (e.tagName.toUpperCase() != 'TD') {\n                        Object(_plugins_task__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(collectRects, [e]);\n                        checkIfReady();\n                    }\n                } else {\n                    checkIfReady();\n                }\n            }\n        };\n        if (element.nodeType == 3) {\n            Object(_plugins_task__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(collectRects, [element]);\n            checkIfReady();\n        } else {\n            walk(element.childNodes);\n        }\n    });\n};\nlet findBreakPoints = rects => {\n    return new Promise(resolve => {\n        let points = [];\n        let checkReady = Object(_plugins_taskcomplete__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(() => {\n            resolve(points.sort());\n        });\n        let test = rect => {\n            let line = rect.y + rect.height;\n            let canInsert = 1;\n            for (let r of rects) {\n                if (r.y + r.height > line &&\n                    r.y < line) {\n                    canInsert = 0;\n                    break;\n                }\n            }\n            if (canInsert &&\n                !points.includes(line)) {\n                points.push(line);\n            }\n            checkReady();\n        };\n        for (let rect of rects) {\n            Object(_plugins_task__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(test, [rect]);\n        }\n    });\n};\nlet hiddenOrClipElement = (e, eBound, end) => {\n    if ((eBound.width || eBound.height) &&\n        end > eBound.y) {\n        if (end > eBound.y + eBound.height) {\n            e.style.visibility = 'hidden';\n        } else {\n            let diff = end - eBound.y;\n            let old = getClipPath(e.style.clipPath);\n            e.style.clipPath = `inset(${diff}px 0 ${old[2]}px)`;\n        }\n    }\n};\nclass ContentNode {\n    constructor(content) {\n        this.$root = getDOMRef(content);\n    }\n    waitResource() {\n        return new Promise(resolve => {\n            let imgs = this.$root.getElementsByTagName('img');\n            let check = () => {\n                if (imgs.length) {\n                    let allReady = 1;\n                    for (let img of imgs) {\n                        if (!img.complete) {\n                            allReady = 0;\n                            break;\n                        } else {\n                            img.style.width = img.clientWidth + 'px';\n                            img.style.height = img.clientHeight + 'px';\n                        }\n                    }\n                    if (allReady) {\n                        if (!this.$destroy) {\n                            resolve();\n                        }\n                    } else {\n                        setTimeout(check, 500);\n                    }\n                } else if (!this.$destroy) {\n                    resolve();\n                }\n            };\n            check();\n        });\n    }\n    getCloneNode() {\n        if (this.$root) {\n            if (this.$root.childNodes.length > 1) {\n                let div = document.createElement('div');\n                let start = 0,\n                    end = this.$root.childNodes.length;\n                while (start < end) {\n                    div.appendChild(this.$root.childNodes[start].cloneNode(true));\n                    start++;\n                }\n                return div;\n            }\n            return this.$root.cloneNode(true);\n        }\n        return null;\n    }\n    getChildNodes() {\n        return this.$root.childNodes;\n    }\n    clean() {\n        if (!this.$destroy) {\n            this.$destroy = 1;\n            if (this.$root) {\n                this.$root.parentNode.removeChild(this.$root);\n            }\n        }\n    }\n}\nclass Spliter {\n    prepare(configs) {\n        let prepareMark = Object(_plugins_mark__WEBPACK_IMPORTED_MODULE_2__[\"mark\"])(this, '#spliter.prepare');\n        return new Promise(async resolve => {\n            let { header, footer, content } = configs;\n            this.$header = new ContentNode(header);\n            this.$footer = new ContentNode(footer);\n            this.$content = new ContentNode(content);\n            await Promise.all([this.$header.waitResource(),\n            this.$footer.waitResource(),\n            this.$content.waitResource()]);\n            if (prepareMark()) {\n                resolve();\n            }\n        });\n    }\n    split(configs, destRoot) {\n        let splitMark = Object(_plugins_mark__WEBPACK_IMPORTED_MODULE_2__[\"mark\"])(this, '#spliter.split');\n        return new Promise(resolve => {\n            Object(_plugins_task__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(() => {\n                while (destRoot.firstChild) {\n                    destRoot.removeChild(destRoot.firstChild);\n                }\n            });\n            let currentContentNode;\n            let currentContentBound;\n            let currentFooterNode;\n            let pageAppendNode = 0;\n            let floatItem = 0;\n            let floatIndex = 0;\n            let floatBound;\n            let floatItemAtTop = 0;\n            let continueMesaurer = document.createElement('div');\n            document.body.appendChild(continueMesaurer);\n            let destRootBound = fixBound(destRoot.getBoundingClientRect());\n            continueMesaurer.style.cssText = `position:absolute;left:${destRootBound.x}px;top:-100000px;height:${configs.pageContinue}mm;width:${destRootBound.width}px;pointer-events:none;background:#0002`;\n            let continueEnd = continueMesaurer.clientHeight;\n            let destContinueEnd = destRootBound.y + continueEnd;\n            this.$continueMesaurer = continueMesaurer;\n            let insertPageNode = () => {\n                if (splitMark()) {\n                    if (currentFooterNode) {\n                        let fb = fixBound(currentFooterNode.getBoundingClientRect());\n                        hiddenOrClipElement(currentFooterNode, fb, destContinueEnd);\n                    }\n                    pageAppendNode = 0;\n                    floatItem = 0;\n                    floatItemAtTop = 0;\n                    let pageNode = document.createElement('div');\n                    pageNode.className = 'print-page';\n                    pageNode.style.cssText = `width:calc(${configs.pageWidth}mm - 2px);height:calc(${configs.pageHeight}mm - 2px);padding:${configs.paddingTop}mm ${configs.paddingRight}mm ${configs.paddingBottom}mm ${configs.paddingLeft}mm`;\n                    destRoot.appendChild(pageNode);\n                    range.setStartBefore(pageNode);\n                    range.setEndAfter(pageNode);\n\n                    let pageHeight = range.getBoundingClientRect().height;\n                    let headerNode = this.$header.getCloneNode();\n                    let headerHeight = 0;\n                    if (headerNode) {\n                        pageNode.appendChild(headerNode);\n                        range.setStartBefore(headerNode);\n                        range.setEndAfter(headerNode);\n                        let headerBound = fixBound(range.getBoundingClientRect());\n                        headerHeight = headerBound.height;\n                        hiddenOrClipElement(headerNode, headerBound, destContinueEnd);\n                    }\n                    let footerNode = this.$footer.getCloneNode();\n                    let footerHeight = 0;\n                    if (footerNode) {\n                        pageNode.appendChild(footerNode);\n                        range.setStartBefore(footerNode);\n                        range.setEndAfter(footerNode);\n                        footerHeight = range.getBoundingClientRect().height;\n                    }\n                    currentFooterNode = footerNode;\n                    let paddingTop = parseInt(getComputedStyle(pageNode).paddingTop, 10);\n                    let paddingBottom = parseInt(getComputedStyle(pageNode).paddingBottom, 10);\n                    let contentNode = document.createElement('div');\n                    contentNode.style.height = Math.max(pageHeight - headerHeight - footerHeight - paddingTop - paddingBottom, 100) + 'px';\n                    contentNode.style.overflow = 'hidden';\n                    pageNode.insertBefore(contentNode, footerNode);\n                    currentContentNode = contentNode;\n                    range.setStartBefore(contentNode);\n                    range.setEndAfter(contentNode);\n                    currentContentBound = fixBound(range.getBoundingClientRect());\n                }\n            };\n            let moveNode = async (n, index, callback, clipTop) => {\n                if (splitMark()) {\n                    if (n.className == 'page-break') {\n                        insertPageNode();\n                        callback();\n                    } else {\n                        n = n.cloneNode(true);\n                        if (clipTop) {\n                            n.style.clipPath = `inset(${clipTop}px 0 0)`;\n                            n.style.marginTop = -clipTop + 'px';\n                        }\n                        currentContentNode.appendChild(n);\n                        range.setStartBefore(n);\n                        range.setEndAfter(n);\n                        let nBound = fixBound(range.getBoundingClientRect());\n                        if (n.nodeType == 1) {\n                            let f = getComputedStyle(n).float;\n                            if (f == 'left' ||\n                                f == 'right') {\n                                floatItemAtTop = !pageAppendNode;\n                                floatBound = nBound;\n                                floatIndex = index;\n                                floatItem = n;\n                            }\n                        }\n                        if (nBound.y + nBound.height >\n                            currentContentBound.y + currentContentBound.height) {\n                            if (floatItem &&\n                                !floatItemAtTop) {\n                                if (nBound.y > floatBound.y &&\n                                    nBound.y < floatBound.y + floatBound.height) {\n                                    while (n != floatItem) {\n                                        let prev = n.previousSibling;\n                                        currentContentNode.removeChild(n);\n                                        n = prev;\n                                    }\n                                    currentContentNode.removeChild(floatItem);\n                                    insertPageNode();\n                                    callback(floatIndex);\n                                    return;\n                                }\n                            }\n                            let rects = await getRectsFromElement(n);\n                            if (splitMark()) {\n                                if (rects.length) {\n                                    let points = await findBreakPoints(rects);\n                                    if (splitMark()) {\n                                        let lastPoint;\n                                        for (let p of points) {\n                                            if (p >= currentContentBound.y + currentContentBound.height) {\n                                                break;\n                                            }\n                                            lastPoint = p;\n                                        }\n                                        let clipTop = 0;\n                                        let nextPageNode;\n                                        let append = pageAppendNode;\n                                        if (lastPoint) {\n                                            lastPoint += 1;\n                                            //appendLine(lastPoint);\n                                            let newHeight = lastPoint - currentContentBound.y;\n                                            let toBottom = currentContentBound.height - newHeight;\n                                            currentContentNode.style.height = newHeight + 'px';\n                                            currentContentNode.style.marginBottom = toBottom + 'px';\n                                            hiddenOrClipElement(n, nBound, destContinueEnd);\n\n                                            nextPageNode = n.cloneNode(true);\n                                            let nodeBound = n.getBoundingClientRect();\n                                            clipTop = lastPoint - (nodeBound.top + window.pageYOffset);\n                                            //let oldClip = getClipPath(n.style.clipPath);\n                                            //let diffToBottom = n.clientHeight - clipTop;\n                                            //n.style.clipPath = `inset(${oldClip[0]}px 0 ${diffToBottom}px 0)`;\n                                            append = 1;\n                                        } else if (append) {\n                                            currentContentNode.removeChild(n);\n                                            nextPageNode = n;\n                                        }\n                                        insertPageNode();\n                                        if (append) {\n                                            Object(_plugins_task__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(moveNode, [nextPageNode, index, callback, clipTop]);\n                                        } else {\n                                            callback();\n                                        }\n                                    }\n                                } else {\n                                    callback();\n                                }\n                            }\n                        } else {\n                            pageAppendNode = 1;\n                            hiddenOrClipElement(n, nBound, destContinueEnd);\n                            callback();\n                        }\n                    }\n                }\n            };\n            Object(_plugins_task__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(insertPageNode);\n            let nodes = Array.from(this.$content.getChildNodes());\n            let index = 0;\n            let moveNext = start => {\n                if (start != null) {\n                    index = start;\n                }\n                if (splitMark() && index < nodes.length) {\n                    Object(_plugins_task__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(moveNode, [nodes[index], index++, moveNext]);\n                } else {\n                    this.clean();\n                    resolve();\n                }\n            };\n            moveNext();\n        });\n    }\n    clean() {\n        Object(_plugins_mark__WEBPACK_IMPORTED_MODULE_2__[\"mark\"])(this, '#spliter.prepare');\n        Object(_plugins_mark__WEBPACK_IMPORTED_MODULE_2__[\"mark\"])(this, '#spliter.split');\n        let cm = this.$continueMesaurer;\n        if (cm) {\n            cm.parentNode.removeChild(cm);\n            this.$continueMesaurer = null;\n        }\n        if (this.$header) {\n            this.$header.clean();\n        }\n        if (this.$footer) {\n            this.$footer.clean();\n        }\n        if (this.$content) {\n            this.$content.clean();\n        }\n    }\n    randomFontsize(destRoot) {\n        return new Promise(resolve => {\n            let checkIfReady = Object(_plugins_taskcomplete__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(() => {\n                console.log('ready');\n                resolve();\n            });\n            let walk = nodes => {\n                for (let n of nodes) {\n                    if (n.nodeType == 3 &&\n                        n.textContent.trim()) {\n                        let after = n.splitText((Math.random() * n.length) | 0);\n                        let span = document.createElement('span');\n                        span.innerHTML = 'fg';\n                        span.style.fontSize = 12 + ((Math.random() * 48) | 0) + 'px';\n                        n.parentNode.insertBefore(span, after);\n                    } else {\n                        Object(_plugins_task__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(walk, [Array.from(n.childNodes)]);\n                        checkIfReady();\n                    }\n                }\n            };\n            walk(Array.from(destRoot.childNodes));\n        });\n    }\n}\n\nclass MagicalTextEditor {\n    static createSpliter() {\n        return new Spliter();\n    }\n}\n\n//# sourceURL=webpack://MagicalTextEditor/./src/mteditor-print.js?");

/***/ }),

/***/ 2:
/*!*************************************!*\
  !*** multi ./src/mteditor-print.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! /Users/kunfeili/Project/mteditor/src/mteditor-print.js */\"./src/mteditor-print.js\");\n\n\n//# sourceURL=webpack://MagicalTextEditor/multi_./src/mteditor-print.js?");

/***/ })

/******/ })["default"];
});